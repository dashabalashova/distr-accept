name: SLURM CI – build -> test -> push

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

env:
  IMAGE_NAME: ghcr.io/dashabalashova/deepspeed-train
  REMOTE_DIR: /root/distr-accept
  SLURM_WAIT_TIMEOUT_SECONDS: 1200

jobs:
  build:
    name: Build image (runner)
    runs-on: self-hosted
    outputs:
      image-tag: ${{ steps.set-tag.outputs.image_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # - name: Set IMAGE_TAG
      #   id: set-tag
      #   run: |
      #     IMAGE_TAG="staging-${GITHUB_RUN_NUMBER}-${GITHUB_SHA::8}"
      #     echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
      #     echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      # - name: Set up QEMU and buildx
      #   uses: docker/setup-buildx-action@v2

      # - name: Build docker image (load into local docker daemon)
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: .
      #     file: ./Dockerfile
      #     push: false
      #     load: true
      #     tags: ${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.image_tag }}

      # - name: Create enroot squashfs (.sqsh) from local docker image
      #   run: |
      #     set -euo pipefail
      #     SQSH_NAME="deepspeed-train-2.sqsh"
      #     echo "Creating enroot squashfs: $SQSH_NAME from ${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.image_tag }}"
      #     enroot import --output "$SQSH_NAME" "dockerd://${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.image_tag }}"

      # # --- directly copy to SLURM host from the self-hosted runner ---
      # - name: Ensure remote dir exists (on SLURM host)
      #   uses: appleboy/ssh-action@v0.1.7
      #   with:
      #     host: ${{ secrets.SLURM_HOST }}
      #     username: ${{ secrets.SLURM_USER }}
      #     key: ${{ secrets.SLURM_SSH_KEY }}
      #     port: ${{ secrets.SLURM_SSH_PORT }}
      #     script: |
      #       # создадим директорию (не упадёт, если уже есть)
      #       mkdir -p "${{ env.REMOTE_DIR }}"
      #       # если нужно создать как root и ssh-пользователь не root — можно использовать sudo (требует sudo без пароля)
      #       # sudo mkdir -p "${{ env.REMOTE_DIR }}" || true

      - name: Copy sqsh + sbatch to SLURM host (direct)
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SLURM_HOST }}
          username: ${{ secrets.SLURM_USER }}
          key: ${{ secrets.SLURM_SSH_KEY }}
          port: ${{ secrets.SLURM_SSH_PORT }}
          source: "slurm_train.sbatch,docker.sh,push_container.sh,train.py"
          target: "${{ env.REMOTE_DIR }}"
          strip_components: 0
      # - name: Copy .sqsh to SLURM host with rsync (shows progress)
      #   run: |
      #     set -euo pipefail
      #     mkdir -p ~/.ssh
      #     echo "${{ secrets.SLURM_SSH_KEY }}" > ~/.ssh/slurm_key
      #     chmod 600 ~/.ssh/slurm_key

      #     # optionally set port variable
      #     SSH_PORT="${{ secrets.SLURM_SSH_PORT || '22' }}"

      #     # touch deepspeed-train-2.sqsh

      #     # single file or directory; -P shows progress and partial transfer support
      #     rsync -avP -e "ssh -i ~/.ssh/slurm_key -p ${SSH_PORT} -o StrictHostKeyChecking=no" \
      #       deepspeed-train-2.sqsh \
      #       "${{ secrets.SLURM_USER }}@${{ secrets.SLURM_HOST }}:${{ env.REMOTE_DIR }}"

      #   shell: bash

  test-on-slurm:
    name: Test on remote SLURM
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Run remote test – submit slurm job and wait
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.SLURM_HOST }}
          username: ${{ secrets.SLURM_USER }}
          key: ${{ secrets.SLURM_SSH_KEY }}
          port: ${{ secrets.SLURM_SSH_PORT }}
          script: |
            set -euo pipefail
            mkdir -p "${{ env.REMOTE_DIR }}"
            cd "${{ env.REMOTE_DIR }}"

            # убедимся, что файлы на месте
            ls -lah .

            NODES=$(scontrol show nodes | grep -c '^NodeName')
            GPUS=$(scontrol show nodes | sed -n 's/.*CfgTRES=.*gres\/gpu=\([0-9][0-9]*\).*/\1/p' | head -n1)
            
            sed -e "s/^#SBATCH --nodes=.*/#SBATCH --nodes=${NODES}/" \
                -e "s/^#SBATCH --gres=gpu:.*/#SBATCH --gres=gpu:${GPUS}/" \
                slurm_train.sbatch > slurm_train.submit.sbatch
            
            JOB_ID=$(sbatch --export=ALL,GPUS_PER_NODE="$GPUS",NNODES="$NODES" slurm_train.submit.sbatch)

            if [ -z "$JOB_ID" ]; then
              echo "Failed to submit job"
              exit 2
            fi
            echo "Submitted job id: $JOB_ID"

            START_TS=$(date +%s)
            TIMEOUT=${{ env.SLURM_WAIT_TIMEOUT_SECONDS }}
            while true; do
              if squeue -j "$JOB_ID" -h -o "%T" >/dev/null 2>&1; then
                STATE=$(squeue -j "$JOB_ID" -h -o "%T" | tr -d '\r')
              else
                STATE=""
              fi

              if [ -z "$STATE" ]; then
                if command -v sacct >/dev/null 2>&1; then
                  INFO=$(sacct -j "$JOB_ID" --format=JobID,State,ExitCode -n -P | head -n 1 || true)
                  EXIT_RC=$(echo "$INFO" | awk -F'|' '{print $3}' | awk -F: '{print $1}')
                  if [ -z "$EXIT_RC" ] || [ "$EXIT_RC" = "0" ]; then
                    echo "Job finished successfully"
                    exit 0
                  else
                    echo "Job failed with exit code $EXIT_RC"
                    exit $EXIT_RC
                  fi
                else
                  echo "sacct not available; assuming success"
                  exit 0
                fi
              fi

              NOW_TS=$(date +%s)
              if [ $((NOW_TS - START_TS)) -gt $TIMEOUT ]; then
                echo "Timeout reached, cancelling job $JOB_ID"
                scancel "$JOB_ID" || true
                exit 124
              fi

              echo "Job $JOB_ID state: $STATE — sleeping 10s..."
              sleep 10
            done

  publish:
    name: Publish image to GHCR (only if SLURM job success)
    needs: [build, test-on-slurm]
    runs-on: ubuntu-latest
    if: ${{ needs.test-on-slurm.result == 'success' }}
    env:
      IMAGE_NAME: ghcr.io/dashabalashova/deepspeed-train
      IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: image-tar
          path: .

  #     - name: Load image into docker
  #       run: |
  #         set -euo pipefail
  #         echo "Loading image tar..."
  #         docker load -i image.tar
  #         echo "Local images after load:"
  #         docker images --format 'table {{.Repository}}:{{.Tag}}\t{{.ID}}\t{{.Size}}'

  #     - name: Login to GHCR
  #       uses: docker/login-action@v2
  #       with:
  #         registry: ghcr.io
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Tag & push image (original tag and :latest)
  #       run: |
  #         set -euo pipefail
  #         ORIG_TAG="${IMAGE_NAME}:${IMAGE_TAG}"
  #         LATEST_TAG="${IMAGE_NAME}:latest"
  #         echo "Tagging (ensuring original tag exists locally): ${ORIG_TAG}"
  #         # If the loaded image has the original tag, this is a no-op; otherwise tag by image id (try to find it)
  #         if ! docker image inspect "${ORIG_TAG}" >/dev/null 2>&1; then
  #           # try to find the image id by repo (first match)
  #           IMG_ID=$(docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' | awk -v repo="${IMAGE_NAME}" '$1 ~ repo { print $2; exit }' || true)
  #           if [ -z "$IMG_ID" ]; then
  #             echo "Cannot find loaded image to tag"
  #             docker images --all
  #             exit 1
  #           fi
  #           docker tag "$IMG_ID" "${ORIG_TAG}"
  #         fi

  #         echo "Pushing ${ORIG_TAG}"
  #         docker push "${ORIG_TAG}"

  #         echo "Tagging as latest: ${LATEST_TAG}"
  #         docker tag "${ORIG_TAG}" "${LATEST_TAG}"
  #         echo "Pushing ${LATEST_TAG}"
  #         docker push "${LATEST_TAG}"

  #     - name: Done
  #       run: echo "Image pushed to GHCR: ${IMAGE_NAME}:latest (and original tag ${IMAGE_TAG})"
