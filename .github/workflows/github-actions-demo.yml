name: SLURM CI – build -> test -> push

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

env:
  IMAGE_NAME: ghcr.io/dashabalashova/deepspeed-train-3
  REMOTE_DIR: /root/distr-accept
  SLURM_WAIT_TIMEOUT_SECONDS: 1200

jobs:
  build:
    name: Build image (runner)
    runs-on: [self-hosted, docker-host]
    outputs:
      image-tag: ${{ steps.set-tag.outputs.image_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set IMAGE_TAG
        id: set-tag
        run: |
          IMAGE_TAG="latest"
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Set up QEMU and buildx
        uses: docker/setup-buildx-action@v2

      - name: Build docker image (load into local docker daemon)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.image_tag }}

      - name: Create enroot squashfs (.sqsh) from local docker image
        run: |
          set -euo pipefail
          SQSH_NAME="deepspeed-train-3.sqsh"
          echo "Creating enroot squashfs: $SQSH_NAME from ${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.image_tag }}"
          enroot import --output "$SQSH_NAME" "dockerd://${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.image_tag }}"
          echo "SQSH_NAME=$SQSH_NAME" >> $GITHUB_ENV

      - name: Ensure remote dir exists (on SLURM host)
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.SLURM_HOST }}
          username: ${{ secrets.SLURM_USER }}
          key: ${{ secrets.SLURM_SSH_KEY }}
          port: ${{ secrets.SLURM_SSH_PORT }}
          script: |
            mkdir -p "${{ env.REMOTE_DIR }}"

      - name: Copy sqsh + sbatch + train.py to SLURM host (direct)
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SLURM_HOST }}
          username: ${{ secrets.SLURM_USER }}
          key: ${{ secrets.SLURM_SSH_KEY }}
          port: ${{ secrets.SLURM_SSH_PORT }}
          source: "slurm_train.sbatch,train.py"
          target: "${{ env.REMOTE_DIR }}"
          strip_components: 0

      - name: Copy .sqsh to SLURM host with rsync (shows progress)
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.SLURM_SSH_KEY }}" > ~/.ssh/slurm_key
          chmod 600 ~/.ssh/slurm_key

          SSH_PORT="${{ secrets.SLURM_SSH_PORT || '22' }}"

          rsync -avP -e "ssh -i ~/.ssh/slurm_key -p ${SSH_PORT} -o StrictHostKeyChecking=no" \
            deepspeed-train-3.sqsh \
            "${{ secrets.SLURM_USER }}@${{ secrets.SLURM_HOST }}:${{ env.REMOTE_DIR }}"

        shell: bash

  test-on-slurm:
    name: Test on remote SLURM
    needs: build
    runs-on: self-hosted
    outputs:
      slurm_status: ${{ steps.parse.outputs.slurm_status }}
      slurm_exit_code: ${{ steps.parse.outputs.slurm_exit_code }}
    steps:
      - name: Run remote test – submit slurm job and wait
        id: run-remote
        uses: appleboy/ssh-action@v0.1.7
        continue-on-error: true                # <-- позволяем шагу завершиться не-0, чтобы потом распарсить stdout
        with:
          host: ${{ secrets.SLURM_HOST }}
          username: ${{ secrets.SLURM_USER }}
          key: ${{ secrets.SLURM_SSH_KEY }}
          port: ${{ secrets.SLURM_SSH_PORT }}
          script: |
            set -euo pipefail
            mkdir -p "${{ env.REMOTE_DIR }}"
            cd "${{ env.REMOTE_DIR }}"
            ls -lah .
            NODES=$(scontrol show nodes | grep -c '^NodeName')
            GPUS=$(scontrol show nodes | sed -n 's/.*CfgTRES=.*gres\/gpu=\([0-9][0-9]*\).*/\1/p' | head -n1)
            sed -e "s/^#SBATCH --nodes=.*/#SBATCH --nodes=${NODES}/" \
                -e "s/^#SBATCH --gres=gpu:.*/#SBATCH --gres=gpu:${GPUS}/" \
                slurm_train.sbatch > slurm_train.submit.sbatch
            SBATCH_OUT=$(sbatch --export=ALL,GPUS_PER_NODE="$GPUS",NNODES="$NODES" slurm_train.submit.sbatch || true)
            if [ -z "$SBATCH_OUT" ]; then
              echo "Failed to submit job"
              echo "JOB_SUBMIT_RESULT=failed"
              exit 3
            fi
            JOB_ID=$(echo "$SBATCH_OUT" | awk '{print $NF}')
            echo "Submitted job id: $JOB_ID"
            START_TS=$(date +%s)
            TIMEOUT=${{ env.SLURM_WAIT_TIMEOUT_SECONDS }}
            while true; do
              if squeue -j "$JOB_ID" -h -o "%T" >/dev/null 2>&1; then
                STATE=$(squeue -j "$JOB_ID" -h -o "%T" | tr -d '\r')
              else
                STATE=""
              fi
              if [ -z "$STATE" ]; then
                if command -v sacct >/dev/null 2>&1; then
                  INFO=$(sacct -j "$JOB_ID" --format=JobID,State,ExitCode -n -P | head -n 1 || true)
                  EXIT_RC=$(echo "$INFO" | awk -F'|' '{print $3}' | awk -F: '{print $1}')
                  if [ -z "$EXIT_RC" ] || [ "$EXIT_RC" = "0" ]; then
                    echo "Job finished successfully"
                    exit 0
                  else
                    echo "Job failed with exit code $EXIT_RC"
                    exit $EXIT_RC
                  fi
                else
                  echo "sacct not available; assuming success"
                  exit 0
                fi
              fi
              NOW_TS=$(date +%s)
              if [ $((NOW_TS - START_TS)) -gt $TIMEOUT ]; then
                echo "Timeout reached, cancelling job $JOB_ID"
                scancel "$JOB_ID" || true
                exit 124
              fi
              echo "Job $JOB_ID state: $STATE — sleeping 10s..."
              sleep 10
            done

      - name: Parse SLURM result from SSH step stdout
        id: parse
        run: |
          # appleboy/ssh-action обычно возвращает stdout в steps.run-remote.outputs.stdout
          STDOUT="${{ steps.run-remote.outputs.stdout || '' }}"

          echo "---- remote stdout (truncated) ----"
          echo "${STDOUT}" | sed -n '1,200p'
          echo "-----------------------------------"

          if echo "$STDOUT" | grep -q "Job finished successfully"; then
            echo "slurm_status=success" >> $GITHUB_OUTPUT
            echo "slurm_exit_code=0" >> $GITHUB_OUTPUT
          elif echo "$STDOUT" | grep -q "Job failed with exit code"; then
            EXIT=$(echo "$STDOUT" | sed -n 's/.*Job failed with exit code \([0-9][0-9]*\).*/\1/p')
            echo "slurm_status=failure" >> $GITHUB_OUTPUT
            echo "slurm_exit_code=${EXIT:-1}" >> $GITHUB_OUTPUT
          elif echo "$STDOUT" | grep -q "Timeout reached, cancelling job"; then
            echo "slurm_status=timeout" >> $GITHUB_OUTPUT
            echo "slurm_exit_code=124" >> $GITHUB_OUTPUT
          else
            # если ничего не понятно — считаем как unknown (без пуша)
            echo "slurm_status=unknown" >> $GITHUB_OUTPUT
            echo "slurm_exit_code=2" >> $GITHUB_OUTPUT
          fi

  publish:
    name: Publish image to GHCR (only if SLURM job success)
    needs: [build, test-on-slurm]
    if: ${{ needs.test-on-slurm.outputs.slurm_status == 'success' }}
    runs-on: [self-hosted, docker-host]
    env:
      IMAGE_NAME: ghcr.io/dashabalashova/deepspeed-train-3
      IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
    steps:
      - name: Debug vars
        run: |
          echo "Will publish image from local Docker daemon"
          echo "IMAGE_NAME=${IMAGE_NAME}"
          echo "IMAGE_TAG=${IMAGE_TAG}"
          docker --version || true
          docker images --format 'table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | sed -n '1,50p' || true

      - name: Ensure image exists locally and push to GHCR
        env:
          CR_PAT: ${{ secrets.CR_PAT }}
        run: |
          set -euo pipefail
          TAG="${IMAGE_NAME}:${IMAGE_TAG}"
          if ! docker image inspect "$TAG" >/dev/null 2>&1; then
            echo "Image $TAG not found in local docker. Available images:"
            docker images --format 'table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' || true
            exit 2
          fi
          echo "Logging in to ghcr.io"
          echo "${CR_PAT}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          echo "Pushing $TAG"
          docker push "$TAG"
